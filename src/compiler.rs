use crate::lexer::BFToken;

pub struct BFCompiler {
    pub tokens: Vec<BFToken>,
    pub tape_size: usize,
}

impl BFCompiler {
    pub fn new(tokens: Vec<BFToken>, tape_size: usize) -> Self {
        BFCompiler { tokens, tape_size }
    }
    pub fn compile(&self, pretty: bool) -> String {
        let mut asm = String::new();
        let indent = if pretty { "    " } else { "" };
        if pretty {
            asm.push_str("; Brainfuck x86-64 Assembly (UNIX)\n");
            asm.push_str("; Generated by BFCompiler\n\n");
        }
        asm.push_str("section .bss\n");
        asm.push_str(&format!("{indent}tape resb {}\n\n", self.tape_size));
        asm.push_str("section .text\n");
        asm.push_str("global _start\n\n");
        asm.push_str("_start:\n");
        asm.push_str(&format!("{indent}mov rsi, tape\n"));
        let mut loop_stack = Vec::new();
        let mut loop_id = 0;
        for token in &self.tokens {
            match token {
                BFToken::IncrementPointer(n) => {
                    asm.push_str(&format!("{indent}add rsi, {}{}\n", n, if pretty {"         ; >"} else {""}));
                }
                BFToken::DecrementPointer(n) => {
                    asm.push_str(&format!("{indent}sub rsi, {}{}\n", n, if pretty {"         ; <"} else {""}));
                }
                BFToken::IncrementValue(n) => {
                    asm.push_str(&format!("{indent}add byte [rsi], {}{}\n", n, if pretty {"  ; +"} else {""}));
                }
                BFToken::DecrementValue(n) => {
                    asm.push_str(&format!("{indent}sub byte [rsi], {}{}\n", n, if pretty {"  ; -"} else {""}));
                }
                BFToken::OutputValue(n) => {
                    for _ in 0..*n {
                        if pretty {
                            asm.push_str(&format!("{indent}; Output current cell\n"));
                        }
                        asm.push_str(&format!("{indent}mov rax, 1{}\n", if pretty {"        ; sys_write"} else {""}));
                        asm.push_str(&format!("{indent}mov rdi, 1{}\n", if pretty {"        ; stdout"} else {""}));
                        asm.push_str(&format!("{indent}mov rdx, 1{}\n", if pretty {"        ; count"} else {""}));
                        // buffer is unneeded since rsi already points to it(self)
                        //asm.push_str(&format!("{indent}mov rsi, rsi{}\n", if pretty {"      ; buffer"} else {""}));
                        asm.push_str(&format!("{indent}syscall\n"));
                    }
                }
                BFToken::InputValue(n) => {
                    for _ in 0..*n {
                        if pretty {
                            asm.push_str(&format!("{indent}; Input to current cell\n"));
                        }
                        asm.push_str(&format!("{indent}mov rax, 0{}\n", if pretty {"        ; sys_read"} else {""}));
                        asm.push_str(&format!("{indent}mov rdi, 0{}\n", if pretty {"        ; stdin"} else {""}));
                        asm.push_str(&format!("{indent}mov rdx, 1{}\n", if pretty {"        ; count"} else {""}));
                        //asm.push_str(&format!("{indent}mov rsi, rsi{}\n", if pretty {"      ; buffer"} else {""}));
                        asm.push_str(&format!("{indent}syscall\n"));
                    }
                }
                BFToken::LoopStart => {
                    let start = format!("loop_start_{}", loop_id);
                    let end = format!("loop_end_{}", loop_id);
                    loop_stack.push((start.clone(), end.clone()));
                    if pretty {
                        asm.push_str(&format!("{indent}; Loop start\n"));
                    }
                    asm.push_str(&format!("{}:\n", start));
                    asm.push_str(&format!("{indent}cmp byte [rsi], 0\n"));
                    asm.push_str(&format!("{indent}je {}\n", end));
                    loop_id += 1;
                }
                BFToken::LoopEnd => {
                    if let Some((start, end)) = loop_stack.pop() {
                        if pretty {
                            asm.push_str(&format!("{indent}; Loop end\n"));
                        }
                        asm.push_str(&format!("{indent}cmp byte [rsi], 0\n"));
                        asm.push_str(&format!("{indent}jne {}\n", start));
                        asm.push_str(&format!("{}:\n", end));
                    }
                }
            }
        }
        // Exit syscall
        if pretty {
            asm.push_str(&format!("{indent}; Exit program\n"));
        }
        asm.push_str(&format!("{indent}mov rax, 60{}\n", if pretty {"       ; sys_exit"} else {""}));
        asm.push_str(&format!("{indent}xor rdi, rdi{}\n", if pretty {"      ; status 0"} else {""}));
        asm.push_str(&format!("{indent}syscall\n"));
        asm
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lexer::BFToken;

    #[test]
    fn test_increment_pointer() {
        let compiler = BFCompiler::new(vec![BFToken::IncrementPointer(3)], 90000);
        let asm = compiler.compile(true);
        assert!(asm.contains("add rsi, 3"));
    }

    #[test]
    fn test_decrement_value_and_output() {
        let compiler = BFCompiler::new(vec![BFToken::DecrementValue(2), BFToken::OutputValue(1)], 90000);
        let asm = compiler.compile(true);
        assert!(asm.contains("sub byte [rsi], 2"));
        assert!(asm.contains("sys_write"));
    }

    #[test]
    fn test_loop_generation() {
        let compiler = BFCompiler::new(vec![BFToken::LoopStart, BFToken::IncrementValue(1), BFToken::LoopEnd], 90000);
        let asm = compiler.compile(true);
        assert!(asm.contains("loop_start_0:"));
        assert!(asm.contains("loop_end_0:"));
        assert!(asm.contains("add byte [rsi], 1"));
    }

    #[test]
    fn test_input_and_exit() {
        let compiler = BFCompiler::new(vec![BFToken::InputValue(1)], 90000);
        let asm = compiler.compile(true);
        assert!(asm.contains("sys_read"));
        assert!(asm.contains("sys_exit"));
    }
}
