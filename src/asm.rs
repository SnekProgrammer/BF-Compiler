#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Assembler {
    pub target_arch: String,
    pub asm: String,
    pub pretty: bool,
    pub tape_size: usize,
}

impl Assembler {
    pub fn new(target_arch: &str, pretty: bool, tape_size: usize) -> Self {
        if !["unix", "win64"].contains(&target_arch) {
            panic!("Unsupported target architecture: {}", target_arch);
        }
        Assembler {
            target_arch: target_arch.to_string(),
            asm: String::new(),
            pretty,
            tape_size,
        }
    }

    
    // Builder functions
    pub fn header(mut self) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                if self.pretty {
                    self.asm.push_str("; Brainfuck x86-64 Assembly (UNIX)\n");
                    self.asm.push_str("; Generated by BFCompiler\n");
                    self.asm.push_str(format!(";\n; Tape size: {}b\n\n", self.tape_size).as_str());
                }
                self.asm.push_str("section .bss\n");
                self.asm.push_str(&format!("{indent}tape resb {}\n\n", self.tape_size));
                self.asm.push_str("section .text\n");
                self.asm.push_str("global _start\n\n");
                self.asm.push_str("_start:\n");
                self.asm.push_str(&format!("{indent}mov rsi, tape\n"));

                self
            },
                "win64" => {
                    let indent = if self.pretty { "    " } else { "" };
                    if self.pretty {
                        self.asm.push_str("; Brainfuck x86-64 Assembly (Windows)\n");
                        self.asm.push_str("; Generated by BFCompiler\n");
                        self.asm.push_str(format!(";\n; Tape size: {}b\n\n", self.tape_size).as_str());
                    }
                    self.asm.push_str("section .data\n");
                    self.asm.push_str("    fmt_char db '%c', 0\n\n");
                    self.asm.push_str("section .bss\n");
                    self.asm.push_str(&format!("{indent}tape resb {}\n\n", self.tape_size));
                    self.asm.push_str("section .text\n");
                    self.asm.push_str("extern printf\n");
                    self.asm.push_str("extern scanf\n");
                    self.asm.push_str("global main\n\n");
                    self.asm.push_str("main:\n");
                    self.asm.push_str(&format!("{indent}sub rsp, 40\n")); // Win64 ABI shadow space
                    self.asm.push_str(&format!("{indent}mov rsi, tape\n"));
                    self
                }



            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn footer(mut self) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                if self.pretty {
                    self.asm.push_str(&format!("\n{indent}; Exit program\n"));
                }
                self.asm.push_str(&format!("{indent}mov rax, 60{}\n", if self.pretty {"       ; sys_exit"} else {""}));
                self.asm.push_str(&format!("{indent}xor rdi, rdi{}\n", if self.pretty {"       ; status 0"} else {""}));
                self.asm.push_str(&format!("{indent}syscall\n"));
                self
            },
                "win64" => {
                    let indent = if self.pretty { "    " } else { "" };
                    if self.pretty {
                        self.asm.push_str(&format!("\n{indent}; Exit program\n"));
                    }
                    self.asm.push_str(&format!("{indent}add rsp, 40\n")); // restore stack
                    self.asm.push_str(&format!("{indent}ret\n"));
                    self
                }
            _ => unreachable!("Unsupported target architecture"),
        }
    }



    // commands
    pub fn inc_pointer(mut self, n: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                self.asm.push_str(&format!("{indent}add rsi, {}{}\n", n, if self.pretty {"         ; >"} else {""}));
                self
            },
                "win64" => {
                    let indent = if self.pretty { "    " } else { "" };
                    self.asm.push_str(&format!("{indent}add rsi, {}{}\n", n, if self.pretty {"         ; >"} else {""}));
                    self
                }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn dec_pointer(mut self, n: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                self.asm.push_str(&format!("{indent}sub rsi, {}{}\n", n, if self.pretty {"         ; <"} else {""}));
                self
            },
                "win64" => {
                    let indent = if self.pretty { "    " } else { "" };
                    self.asm.push_str(&format!("{indent}sub rsi, {}{}\n", n, if self.pretty {"         ; <"} else {""}));
                    self
                }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn inc_value(mut self, n: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                self.asm.push_str(&format!("{indent}add byte [rsi], {}{}\n", n, if self.pretty {"  ; +"} else {""}));
                self
            },
                "win64" => {
                    let indent = if self.pretty { "    " } else { "" };
                    self.asm.push_str(&format!("{indent}add byte [rsi], {}{}\n", n, if self.pretty {"  ; +"} else {""}));
                    self
                }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn dec_value(mut self, n: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                self.asm.push_str(&format!("{indent}sub byte [rsi], {}{}\n", n, if self.pretty {"  ; -"} else {""}));
                self
            },
                "win64" => {
                    let indent = if self.pretty { "    " } else { "" };
                    self.asm.push_str(&format!("{indent}sub byte [rsi], {}{}\n", n, if self.pretty {"  ; -"} else {""}));
                    self
                }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn output_value(mut self, n: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                for _ in 0..n {
                    if self.pretty {
                        self.asm.push_str(&format!("{indent}; Output current cell\n"));
                    }
                    self.asm.push_str(&format!("{indent}mov rax, 1{}\n", if self.pretty {"        ; sys_write"} else {""}));
                    self.asm.push_str(&format!("{indent}mov rdi, 1{}\n", if self.pretty {"        ; stdout"} else {""}));
                    self.asm.push_str(&format!("{indent}mov rdx, 1{}\n", if self.pretty {"        ; count"} else {""}));
                    // buffer is unneeded since rsi already points to it
                    self.asm.push_str(&format!("{indent}syscall\n"));
                }
                self
            },
                "win64" => {
                    let indent = if self.pretty { "    " } else { "" };
                    for _ in 0..n {
                        if self.pretty {
                            self.asm.push_str(&format!("{indent}; Output current cell\n"));
                        }
                        // Windows: call printf("%c", [rsi])
                        self.asm.push_str(&format!("{indent}mov rcx, fmt_char\n")); // first arg: format string
                        self.asm.push_str(&format!("{indent}mov rdx, [rsi]\n"));   // second arg: value
                        self.asm.push_str(&format!("{indent}call printf\n"));
                    }
                    self
                }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn input_value(mut self, n: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                for _ in 0..n {
                    if self.pretty {
                        self.asm.push_str(&format!("{indent}; Input to current cell\n"));
                    }
                    self.asm.push_str(&format!("{indent}mov rax, 0{}\n", if self.pretty {"        ; sys_read"} else {""}));
                    self.asm.push_str(&format!("{indent}mov rdi, 0{}\n", if self.pretty {"        ; stdin"} else {""}));
                    self.asm.push_str(&format!("{indent}mov rdx, 1{}\n", if self.pretty {"        ; count"} else {""}));
                    // buffer is unneeded since rsi already points to it
                    self.asm.push_str(&format!("{indent}syscall\n"));
                }
                self
            },
                "win64" => {
                    let indent = if self.pretty { "    " } else { "" };
                    for _ in 0..n {
                        if self.pretty {
                            self.asm.push_str(&format!("{indent}; Input to current cell\n"));
                        }
                        // Windows: call scanf("%c", [rsi])
                        self.asm.push_str(&format!("{indent}mov rcx, fmt_char\n")); // first arg: format string
                        self.asm.push_str(&format!("{indent}mov rdx, rsi\n"));       // second arg: pointer to cell
                        self.asm.push_str(&format!("{indent}call scanf\n"));
                    }
                    self
                }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn loop_start(mut self, loop_id: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                let start = format!("loop_start_{}", loop_id);
                let end = format!("loop_end_{}", loop_id);
                if self.pretty {
                    self.asm.push_str(&format!("{indent}; Loop start\n"));
                }
                self.asm.push_str(&format!("{}:\n", start));
                self.asm.push_str(&format!("{indent}cmp byte [rsi], 0\n"));
                self.asm.push_str(&format!("{indent}je {}\n", end));
                self
            },
                "win64" => {
                    let indent = if self.pretty { "    " } else { "" };
                    let start = format!("loop_start_{}", loop_id);
                    let end = format!("loop_end_{}", loop_id);
                    if self.pretty {
                        self.asm.push_str(&format!("{indent}; Loop start\n"));
                    }
                    self.asm.push_str(&format!("{}:\n", start));
                    self.asm.push_str(&format!("{indent}cmp byte [rsi], 0\n"));
                    self.asm.push_str(&format!("{indent}je {}\n", end));
                    self
                }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn loop_end(mut self, loop_id: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                let start = format!("loop_start_{}", loop_id);
                let end = format!("loop_end_{}", loop_id);
                if self.pretty {
                    self.asm.push_str(&format!("{indent}; Loop end\n"));
                }
                self.asm.push_str(&format!("{indent}cmp byte [rsi], 0\n"));
                self.asm.push_str(&format!("{indent}jne {}\n", start));
                self.asm.push_str(&format!("{}:\n", end));
                self
            },
                "win64" => {
                    let indent = if self.pretty { "    " } else { "" };
                    let start = format!("loop_start_{}", loop_id);
                    let end = format!("loop_end_{}", loop_id);
                    if self.pretty {
                        self.asm.push_str(&format!("{indent}; Loop end\n"));
                    }
                    self.asm.push_str(&format!("{indent}cmp byte [rsi], 0\n"));
                    self.asm.push_str(&format!("{indent}jne {}\n", start));
                    self.asm.push_str(&format!("{}:\n", end));
                    self
                }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn build(self) -> String {
    self.asm
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_header_unix_pretty() {
        let asm = Assembler::new("unix", true, 100).header().build();
        assert!(asm.contains("; Brainfuck x86-64 Assembly (UNIX)"));
        assert!(asm.contains("tape resb 100"));
        assert!(asm.contains("mov rsi, tape"));
    }

    #[test]
    fn test_header_win64_pretty() {
        let asm = Assembler::new("win64", true, 200).header().build();
        assert!(asm.contains("; Brainfuck x86-64 Assembly (Windows)"));
        assert!(asm.contains("tape resb 200"));
        assert!(asm.contains("mov rsi, tape"));
    }

    #[test]
    fn test_footer_unix() {
        let asm = Assembler::new("unix", false, 10).footer().build();
        assert!(asm.contains("mov rax, 60"));
        assert!(asm.contains("syscall"));
    }

    #[test]
    fn test_footer_win64() {
        let asm = Assembler::new("win64", false, 10).footer().build();
        assert!(asm.contains("add rsp, 40"));
        assert!(asm.contains("ret"));
    }

    #[test]
    fn test_inc_pointer() {
        let asm = Assembler::new("unix", false, 10).inc_pointer(3).build();
        assert!(asm.contains("add rsi, 3"));
    }

    #[test]
    fn test_dec_pointer() {
        let asm = Assembler::new("win64", false, 10).dec_pointer(2).build();
        assert!(asm.contains("sub rsi, 2"));
    }

    #[test]
    fn test_inc_value() {
        let asm = Assembler::new("unix", false, 10).inc_value(5).build();
        assert!(asm.contains("add byte [rsi], 5"));
    }

    #[test]
    fn test_dec_value() {
        let asm = Assembler::new("win64", false, 10).dec_value(4).build();
        assert!(asm.contains("sub byte [rsi], 4"));
    }

    #[test]
    fn test_output_value_unix() {
        let asm = Assembler::new("unix", false, 10).output_value(1).build();
        assert!(asm.contains("mov rax, 1"));
        assert!(asm.contains("syscall"));
    }

    #[test]
    fn test_output_value_win64() {
        let asm = Assembler::new("win64", false, 10).output_value(1).build();
        assert!(asm.contains("call printf"));
    }

    #[test]
    fn test_input_value_unix() {
        let asm = Assembler::new("unix", false, 10).input_value(1).build();
        assert!(asm.contains("mov rax, 0"));
        assert!(asm.contains("syscall"));
    }

    #[test]
    fn test_input_value_win64() {
        let asm = Assembler::new("win64", false, 10).input_value(1).build();
        assert!(asm.contains("call scanf"));
    }

    #[test]
    fn test_loop_start_end_unix() {
        let asm = Assembler::new("unix", false, 10)
            .loop_start(42)
            .loop_end(42)
            .build();
        assert!(asm.contains("loop_start_42:"));
        assert!(asm.contains("loop_end_42:"));
    }

    #[test]
    fn test_loop_start_end_win64() {
        let asm = Assembler::new("win64", false, 10)
            .loop_start(99)
            .loop_end(99)
            .build();
        assert!(asm.contains("loop_start_99:"));
        assert!(asm.contains("loop_end_99:"));
    }
}