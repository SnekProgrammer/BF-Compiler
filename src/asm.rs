#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Assembler {
    pub target_arch: String,
    pub asm: String,
    pub pretty: bool,
    pub tape_size: usize,
}

impl Assembler {
    pub fn new(target_arch: &str, pretty: bool, tape_size: usize) -> Self {
        if !["unix", "win64"].contains(&target_arch) {
            panic!("Unsupported target architecture: {}", target_arch);
        }
        Assembler {
            target_arch: target_arch.to_string(),
            asm: String::new(),
            pretty,
            tape_size,
        }
    }

    
    // Builder functions
    pub fn header(mut self) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                if self.pretty {
                    self.asm.push_str("; Brainfuck x86-64 Assembly (UNIX)\n");
                    self.asm.push_str("; Generated by BFCompiler\n");
                    self.asm.push_str(format!(";\n; Tape size: {}b\n\n", self.tape_size).as_str());
                }
                self.asm.push_str("section .bss\n");
                self.asm.push_str(&format!("{indent}tape resb {}\n\n", self.tape_size));
                self.asm.push_str("section .text\n");
                self.asm.push_str("global _start\n\n");
                self.asm.push_str("_start:\n");
                self.asm.push_str(&format!("{indent}mov rsi, tape\n"));

                self
            },
            "win64" => {
                panic!("Windows x64 target not yet supported");
            }



            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn footer(mut self) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                if self.pretty {
                    self.asm.push_str(&format!("\n{indent}; Exit program\n"));
                }
                self.asm.push_str(&format!("{indent}mov rax, 60{}\n", if self.pretty {"       ; sys_exit"} else {""}));
                self.asm.push_str(&format!("{indent}xor rdi, rdi{}\n", if self.pretty {"       ; status 0"} else {""}));
                self.asm.push_str(&format!("{indent}syscall\n"));
                self
            },
            "win64" => {
                panic!("Windows x64 target not yet supported");
            }
            _ => unreachable!("Unsupported target architecture"),
        }
    }



    // commands
    pub fn inc_pointer(mut self, n: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                self.asm.push_str(&format!("{indent}add rsi, {}{}\n", n, if self.pretty {"         ; >"} else {""}));
                self
            },
            "win64" => {
                panic!("Windows x64 target not yet supported");
            }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn dec_pointer(mut self, n: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                self.asm.push_str(&format!("{indent}sub rsi, {}{}\n", n, if self.pretty {"         ; <"} else {""}));
                self
            },
            "win64" => {
                panic!("Windows x64 target not yet supported");
            }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn inc_value(mut self, n: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                self.asm.push_str(&format!("{indent}add byte [rsi], {}{}\n", n, if self.pretty {"  ; +"} else {""}));
                self
            },
            "win64" => {
                panic!("Windows x64 target not yet supported");
            }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn dec_value(mut self, n: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                self.asm.push_str(&format!("{indent}sub byte [rsi], {}{}\n", n, if self.pretty {"  ; -"} else {""}));
                self
            },
            "win64" => {
                panic!("Windows x64 target not yet supported");
            }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn output_value(mut self, n: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                for _ in 0..n {
                    if self.pretty {
                        self.asm.push_str(&format!("{indent}; Output current cell\n"));
                    }
                    self.asm.push_str(&format!("{indent}mov rax, 1{}\n", if self.pretty {"        ; sys_write"} else {""}));
                    self.asm.push_str(&format!("{indent}mov rdi, 1{}\n", if self.pretty {"        ; stdout"} else {""}));
                    self.asm.push_str(&format!("{indent}mov rdx, 1{}\n", if self.pretty {"        ; count"} else {""}));
                    // buffer is unneeded since rsi already points to it
                    self.asm.push_str(&format!("{indent}syscall\n"));
                }
                self
            },
            "win64" => {
                panic!("Windows x64 target not yet supported");
            }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn input_value(mut self, n: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                for _ in 0..n {
                    if self.pretty {
                        self.asm.push_str(&format!("{indent}; Input to current cell\n"));
                    }
                    self.asm.push_str(&format!("{indent}mov rax, 0{}\n", if self.pretty {"        ; sys_read"} else {""}));
                    self.asm.push_str(&format!("{indent}mov rdi, 0{}\n", if self.pretty {"        ; stdin"} else {""}));
                    self.asm.push_str(&format!("{indent}mov rdx, 1{}\n", if self.pretty {"        ; count"} else {""}));
                    // buffer is unneeded since rsi already points to it
                    self.asm.push_str(&format!("{indent}syscall\n"));
                }
                self
            },
            "win64" => {
                panic!("Windows x64 target not yet supported");
            }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn loop_start(mut self, loop_id: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                let start = format!("loop_start_{}", loop_id);
                let end = format!("loop_end_{}", loop_id);
                if self.pretty {
                    self.asm.push_str(&format!("{indent}; Loop start\n"));
                }
                self.asm.push_str(&format!("{}:\n", start));
                self.asm.push_str(&format!("{indent}cmp byte [rsi], 0\n"));
                self.asm.push_str(&format!("{indent}je {}\n", end));
                self
            },
            "win64" => {
                panic!("Windows x64 target not yet supported");
            }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn loop_end(mut self, loop_id: u32) -> Self {
        match self.target_arch.as_str() {
            "unix" => {
                let indent = if self.pretty { "    " } else { "" };
                let start = format!("loop_start_{}", loop_id);
                let end = format!("loop_end_{}", loop_id);
                if self.pretty {
                    self.asm.push_str(&format!("{indent}; Loop end\n"));
                }
                self.asm.push_str(&format!("{indent}cmp byte [rsi], 0\n"));
                self.asm.push_str(&format!("{indent}jne {}\n", start));
                self.asm.push_str(&format!("{}:\n", end));
                self
            },
            "win64" => {
                panic!("Windows x64 target not yet supported");
            }
            _ => unreachable!("Unsupported target architecture"),
        }
    }

    pub fn build(self) -> String {
        self.asm
    }
}